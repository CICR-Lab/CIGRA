function [AttackStrategy, PowerSysFunLoss, WaterSysFunLoss] = ...
    NLcAttacterRobPowerMFWaterMFOperator(PowerSystem, WaterSystem, PowerWaterInterdependency, OperatorParams, AttackParams, TerminalZone, SAParams)
% NLcAttacterRobPowerMFWaterMFOperator: Search for worst-case attack strategy on integrated power-water systems
% 
% Purpose: Use Simulated Annealing (SA) to identify the most destructive attack strategy for the 
%          power-water interdependent system under budget constraints. The core goal is to minimize 
%          the normalized total remaining functionality of the two systems.
% 
% Algorithm: The objective function J is defined as the sum of normalized remaining functionalities 
%            of the power and water systems:
%            J = (Post-attack Power Functionality / Initial Power Functionality) + 
%                (Post-attack Water Functionality / Initial Water Functionality)
%            A smaller J value indicates a more severe (worst-case) attack. System functionality 
%            is evaluated by calling the pre-implemented function GlobalOptRobPowerMFWaterMF.
% 
% Input Arguments:
%   - PowerSystem: Structure containing power system data (includes Nodes and Edges with unique IDs 
%                  and operational parameters)
%   - WaterSystem: Structure containing water system data (includes Nodes and Edges with unique IDs 
%                  and operational parameters)
%   - PowerWaterInterdependency: Structure defining interdependent relationships between the power 
%                                and water systems (e.g., power supply for water pumps)
%   - OperatorParams: Structure with operational parameters for evaluating system functionality 
%                     post-attack
%   - AttackParams: Structure with attack-related configuration:
%     - Budget: Total allowable cost for the attack (mandatory field)
%     - PowerNodeAttackCost/PowerEdgeAttackCost: Cost to attack power system nodes/edges (default = 1)
%     - WaterNodeAttackCost/WaterEdgeAttackCost: Cost to attack water system nodes/edges (default = 1)
%     - InvulPowerNode/InvulPowerEdge: IDs of invulnerable power system nodes/edges (cannot be attacked)
%     - InvulWaterNode/InvulWaterEdge: IDs of invulnerable water system nodes/edges (cannot be attacked)
%     - InvalidStrategy: Optional rules to exclude specific attack combinations (supports function handle, 
%                        struct array, or cell array format)
%   - SAParams: Structure with Simulated Annealing algorithm parameters:
%     - T0: Initial temperature (default = 1.0)
%     - alpha: Cooling rate (default = 0.90)
%     - L: Number of iterations per temperature level (default = 50)
%     - Tmin: Minimum temperature to stop the algorithm (default = 1e-3)
%     - MaxNoImprove: Maximum iterations without improving the best solution (default = 300)
% 
% Output Arguments:
%   - AttackStrategy: Structure specifying the optimal attack targets:
%     - AttackStrategy.Power.Node: IDs of attacked power system nodes
%     - AttackStrategy.Power.Edge: IDs of attacked power system edges
%     - AttackStrategy.Water.Node: IDs of attacked water system nodes
%     - AttackStrategy.Water.Edge: IDs of attacked water system edges
%   - PowerSysFunLoss: 1x3 vector of power system functionality metrics:
%     - PowerSysFunLoss(1): Functionality loss post-attack
%     - PowerSysFunLoss(2): Remaining functionality post-attack
%     - PowerSysFunLoss(3): Initial functionality before attack
%   - WaterSysFunLoss: 1x3 vector of water system functionality metrics (same structure as PowerSysFunLoss)
% 
% Key Implementation Notes:
%   1. Unified component coding: Maps 4 component types (Pnode, Pedge, Wnode, Wedge) to non-overlapping 
%      global indices for centralized processing.
%   2. Constraint handling: Supports invulnerable component sets and optional invalid attack combinations 
%      to avoid unrealistic strategies.
%   3. Neighborhood generation: Uses 3 operations (add/drop/swap) to generate new solutions, with 
%      automatic budget repair to ensure feasibility.
%   4. Evaluation caching: Uses containers.Map to store results of previously evaluated attack strategies, 
%      avoiding redundant MILP (Mixed-Integer Linear Programming) computations.
%   5. Objective direction: Smaller J values represent worse attacks; SA accepts both better and worse 
%      solutions (via Metropolis criterion) to escape local optima.
% 
% Author: Generated by ChatGPT

%% ------------------------ 0. Safety & Default Parameter Initialization ------------------------
% Initialize random number generator for reproducible random selections
rng('shuffle');

% Set default SA parameters if SAParams is missing or empty
if nargin < 7 || isempty(SAParams)
    SAParams = struct();
end
% Default SA parameter template
defSA = struct('T0', 1.0, 'alpha', 0.90, 'L', 50, 'Tmin', 1e-3, 'MaxNoImprove', 300);
SAParams = apply_default(SAParams, defSA);

% Initialize attack parameters if AttackParams is missing or empty
if nargin < 5 || isempty(AttackParams)
    AttackParams = struct();
end
% Enforce mandatory budget field (throw error if missing)
if ~isfield(AttackParams, 'Budget')
    error('AttackParams must contain the mandatory ''Budget'' field (total attack cost limit).');
end

% Extract unique IDs of all components from power and water systems
PnodeID = [PowerSystem.Node.ID];      Np = numel(PnodeID);  % Count of power nodes
PedgeID = [PowerSystem.Edge.ID];      Ep = numel(PedgeID);  % Count of power edges
WnodeID = [WaterSystem.Node.ID];      Nw = numel(WnodeID);  % Count of water nodes
WedgeID = [WaterSystem.Edge.ID];      Ew = numel(WedgeID);  % Count of water edges

% Get attack costs for each component (use default 1 if not specified in AttackParams)
% Validate cost vector length matches component count to avoid mismatches
cPnode = get_or_default(AttackParams, 'PowerNodeAttackCost', ones(1, Np), Np);
cPedge = get_or_default(AttackParams, 'PowerEdgeAttackCost', ones(1, Ep), Ep);
cWnode = get_or_default(AttackParams, 'WaterNodeAttackCost', ones(1, Nw), Nw);
cWedge = get_or_default(AttackParams, 'WaterEdgeAttackCost', ones(1, Ew), Ew);

% Define invulnerable components (cannot be attacked) - deduplicate IDs to avoid duplicates
invPN = unique(get_or_default(AttackParams, 'InvulPowerNode', [], 0));  % Invulnerable power nodes
invPE = unique(get_or_default(AttackParams, 'InvulPowerEdge', [], 0));  % Invulnerable power edges
invWN = unique(get_or_default(AttackParams, 'InvulWaterNode', [], 0));  % Invulnerable water nodes
invWE = unique(get_or_default(AttackParams, 'InvulWaterEdge', [], 0));  % Invulnerable water edges

% Initialize invalid attack strategies (optional rules to exclude specific combinations)
InvalidStrategy = [];
if isfield(AttackParams, 'InvalidStrategy') && ~isempty(AttackParams.InvalidStrategy)
    InvalidStrategy = AttackParams.InvalidStrategy;
end

% Extract total attack budget (finalize after parameter initialization)
Budget = AttackParams.Budget;

%% ------------------------ 1. Unified Coding & Feasible Region Definition ------------------------
% Map 4 component types to non-overlapping global indices (1-based) for centralized processing
idx.Pnode = 1:Np;                          % Global indices for power nodes
idx.Pedge = Np + (1:Ep);                   % Global indices for power edges
idx.Wnode = Np + Ep + (1:Nw);              % Global indices for water nodes
idx.Wedge = Np + Ep + Nw + (1:Ew);         % Global indices for water edges
Ntot = Np + Ep + Nw + Ew;                  % Total number of components across both systems

% Build global cost array (cost to attack each component via global index)
cost = zeros(1, Ntot);
cost(idx.Pnode) = cPnode;
cost(idx.Pedge) = cPedge;
cost(idx.Wnode) = cWnode;
cost(idx.Wedge) = cWedge;

% Create mask for attackable components (true = allowed to attack; false = invulnerable)
canAttack = true(1, Ntot);
% Mark invulnerable components as unattackable by their IDs
canAttack(idx.Pnode(ismember(PnodeID, invPN))) = false;
canAttack(idx.Pedge(ismember(PedgeID, invPE))) = false;
canAttack(idx.Wnode(ismember(WnodeID, invWN))) = false;
canAttack(idx.Wedge(ismember(WedgeID, invWE))) = false;

% Handle non-positive attack costs (invalid, mark as unattackable to avoid logical errors)
if any(cost <= 0)
    warnIdx = find(cost <= 0);
    warning('Non-positive attack costs detected. Marked %d components as unattackable.', numel(warnIdx));
    canAttack(warnIdx) = false;
    cost(warnIdx) = inf;  % Set cost to infinity to prevent accidental selection
end

% Get indices of feasible attack candidates (only components marked as attackable)
candIdx = find(canAttack);
% Edge case: No attackable components available (return empty strategy immediately)
if isempty(candIdx)
    warning('No attackable components found. Returning empty attack strategy.');
    AttackStrategy = empty_strategy();
    [PowerSysFunLoss, WaterSysFunLoss] = evaluate_strategy([], idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
        PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams);
    return;
end

%% ------------------------ 2. Initial Solution Generation (Random Feasible) ------------------------
x = false(1, Ntot);  % Binary vector: true = component is attacked, false = not attacked
% Shuffle candidate components to ensure randomness in initial selection
candShuffled = candIdx(randperm(numel(candIdx)));
remainB = Budget;    % Remaining budget for building the initial solution

% Construct initial solution by adding components within budget (check invalid rules)
for k = 1:numel(candShuffled)
    j = candShuffled(k);
    % Only select the component if its cost is within the remaining budget
    if cost(j) <= remainB
        x(j) = true;
        % Revert selection if it violates invalid attack strategy rules
        if ~is_valid_with_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidStrategy)
            x(j) = false;
        else
            remainB = remainB - cost(j);  % Update remaining budget after valid selection
        end
    end
end
% Final budget repair: Ensure initial solution does not exceed the total budget
x = repair_budget(x, cost, Budget, idx);

% Evaluate the initial solution to get functionality losses and objective value J
[PowerSysFunLoss, WaterSysFunLoss, Jx] = ...
    evaluate_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
        PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams);

% Initialize tracker for the best solution found so far
best.x   = x;               % Best attack selection vector
best.J   = Jx;              % Best objective value (smallest = worst attack)
best.FPL = PowerSysFunLoss; % Best power system functionality loss
best.FWL = WaterSysFunLoss; % Best water system functionality loss

%% ------------------------ 3. Simulated Annealing Main Loop ------------------------
% Extract SA algorithm parameters from the structured input
T        = SAParams.T0;          % Initial temperature
L        = SAParams.L;           % Number of iterations per temperature level
alp      = SAParams.alpha;       % Temperature cooling rate (T = T * alp each cycle)
Tmin     = SAParams.Tmin;        % Minimum temperature to terminate the algorithm
maxNoImp = SAParams.MaxNoImprove;% Maximum iterations without improving the best solution
noImpCount = 0;                  % Counter for iterations without improvement

% Initialize evaluation cache: Stores J and functionality losses for existing attack strategies
% Reduces redundant calls to the computationally expensive MILP evaluation function
eval_cache = containers.Map('KeyType', 'char', 'ValueType', 'any');

% Cache the evaluation results of the initial solution
key = key_of(x);
eval_cache(key) = {Jx, PowerSysFunLoss, WaterSysFunLoss};

% Main SA loop: Run until temperature drops below Tmin or no improvement for maxNoImp cycles
while T > Tmin && noImpCount < maxNoImp
    improved_in_T = false;  % Flag to track if the best solution is improved in current temperature level

    % Perform L iterations (neighborhood searches) at the current temperature
    for it = 1:L
        % Generate a new neighborhood solution using add/drop/swap operations
        x_new = neighbor(x, canAttack, cost, Budget, idx);

        % Check if the new solution violates invalid rules; repair if necessary
        if ~is_valid_with_rules(x_new, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidStrategy)
            % Simple repair: Randomly remove one attacked component to resolve invalidity
            x_new = fix_invalid_rules(x_new, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidStrategy);
        end
        % Ensure the new solution is budget-feasible (critical for validity)
        x_new = repair_budget(x_new, cost, Budget, idx);

        % Generate a unique key for cache lookup (based on attacked component indices)
        key = key_of(x_new);
        % Retrieve cached results if available; compute new results otherwise
        if isKey(eval_cache, key)
            val = eval_cache(key);
            Jnew = val{1};       % Objective value of the new solution
            Pnew = val{2};       % Power system functionality loss of the new solution
            Wnew = val{3};       % Water system functionality loss of the new solution
        else
            % Evaluate the new solution if not in cache
            [Pnew, Wnew, Jnew] = evaluate_strategy(x_new, idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
                PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams);
            % Store the new evaluation results in cache for future use
            eval_cache(key) = {Jnew, Pnew, Wnew};
        end

        % Metropolis criterion: Decide whether to accept the new solution
        dJ = Jnew - Jx;  % Difference in objective value (dJ < 0 = better solution)
        % Accept better solutions (dJ < 0) or worse solutions with probability exp(-dJ/T)
        if dJ < 0 || rand < exp(-dJ / max(T, eps))
            % Update current solution to the accepted new solution
            x = x_new;
            Jx = Jnew;
            PowerSysFunLoss = Pnew;
            WaterSysFunLoss = Wnew;

            % Update the best solution if the current solution is significantly better (numerical tolerance)
            if Jx < best.J - 1e-12
                best.x = x;
                best.J = Jx;
                best.FPL = PowerSysFunLoss;
                best.FWL = WaterSysFunLoss;
                improved_in_T = true;  % Mark that improvement occurred in this temperature level
            end
        end
    end

    % Cool down the temperature for the next cycle
    T = T * alp;
    % Update no-improvement counter: Reset if improved, increment otherwise
    if improved_in_T
        noImpCount = 0;
    else
        noImpCount = noImpCount + 1;
    end
end

%% ------------------------ 4. Output Optimal Solution ------------------------
% Convert the best binary attack vector to a structured attack strategy (human-readable component IDs)
AttackStrategy = vec_to_strategy(best.x, idx, PnodeID, PedgeID, WnodeID, WedgeID);
% Extract the functionality losses from the best solution for output
PowerSysFunLoss = best.FPL;
WaterSysFunLoss = best.FWL;

end

%% ====================== Helper Function Section ======================
function S = empty_strategy()
% empty_strategy: Create an empty attack strategy structure (no components attacked)
% Output:
%   - S: Empty strategy structure with fields for power and water system components
S.Power.Node = [];
S.Power.Edge = [];
S.Water.Node = [];
S.Water.Edge = [];
end

function SA = apply_default(SA, DEF)
% apply_default: Fill missing fields in the SA parameter structure with default values
% Inputs:
%   - SA: Input SA structure (may have missing or empty fields)
%   - DEF: Structure containing default values for all required SA fields
% Output:
%   - SA: Updated SA structure with missing fields populated by default values
fns = fieldnames(DEF);
for i = 1:numel(fns)
    f = fns{i};
    % Set field to default if it is missing or empty
    if ~isfield(SA, f) || isempty(SA.(f))
        SA.(f) = DEF.(f);
    end
end
end

function v = get_or_default(st, fname, defv, expectLen)
% get_or_default: Retrieve a value from a structure field, or return a default if the field is missing/empty
% Inputs:
%   - st: Input structure to query for the field
%   - fname: Name of the field to retrieve
%   - defv: Default value to use if the field is missing or empty
%   - expectLen: Expected length of the value (0 = skip length validation)
% Output:
%   - v: Retrieved field value or default value (throws error if length mismatch)
if isfield(st, fname) && ~isempty(st.(fname))
    v = st.(fname);
else
    v = defv;
end
% Validate value length if required (ensures consistency with component counts)
if expectLen > 0 && numel(v) ~= expectLen
    error('Field ''%s'' length mismatch: Expected %d elements, got %d.', fname, expectLen, numel(v));
end
end

function key = key_of(x)
% key_of: Generate a unique string key for a binary attack vector (used for cache lookup)
% Input:
%   - x: Binary vector representing the attack strategy (true = attacked)
% Output:
%   - key: Comma-separated string of indices of attacked components (empty vector = '[]')
idx = find(x);
if isempty(idx)
    key = '[]';
    return;
end
key = sprintf('%d,', idx);
end

function x = repair_budget(x, cost, B, idx)
% repair_budget: Ensure an attack vector stays within the total budget by removing high-cost components
% Inputs:
%   - x: Binary attack vector (may exceed the budget)
%   - cost: Global array of attack costs for all components
%   - B: Total allowable attack budget
%   - idx: Structure of global indices (unused here, retained for function signature consistency)
% Output:
%   - x: Budget-feasible binary attack vector
% Exit early if the current vector is already within budget
totalCost = sum(cost(x));
if totalCost <= B
    return;
end
% Get indices of currently attacked components
attackedIdx = find(x);
% Sort attacked components by cost (descending): Remove most expensive components first for efficiency
[~, sortedCostIdx] = sort(cost(attackedIdx), 'descend');
% Remove components one by one until the budget constraint is satisfied
for k = 1:numel(sortedCostIdx)
    x(attackedIdx(sortedCostIdx(k))) = false;
    if sum(cost(x)) <= B
        break;
    end
end
end

function ok = is_valid_with_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidRule)
% is_valid_with_rules: Check if an attack vector violates the specified invalid strategy rules
% Inputs:
%   - x: Binary attack vector to validate
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
%   - InvalidRule: Invalid strategy rules (supports 3 formats: function handle, struct array, cell array)
% Output:
%   - ok: true = valid (no rule violation), false = invalid
ok = true;
% Exit early if no invalid rules are defined
if isempty(InvalidRule)
    return;
end

% Convert the binary vector to a structured attack strategy for rule checking
S = vec_to_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID);

% Case 1: InvalidRule is a function handle (returns true if the strategy is invalid)
if isa(InvalidRule, 'function_handle')
    ok = ~InvalidRule(S);  % Invert result: Function returns true = invalid ¡ú ok = false
    return;
end

% Case 2: InvalidRule is a struct array or cell array (use try-catch for robustness)
try
    if isstruct(InvalidRule)
        % Struct array format: Each struct defines mutually exclusive components of the same type
        % Struct fields: .Type (component type, e.g., 'Pnode'), .IDs (mutually exclusive component IDs)
        for i = 1:numel(InvalidRule)
            compType = InvalidRule(i).Type;
            exclIDs = InvalidRule(i).IDs(:)';
            % Get IDs of attacked components of the specified type
            attackedIDs = pick_ids(S, compType);
            % Violation if 2 or more mutually exclusive components are attacked
            if numel(intersect(attackedIDs, exclIDs)) >= 2
                ok = false;
                return;
            end
        end
    elseif iscell(InvalidRule)
        % Cell array format: Each cell defines a set of components that cannot all be attacked
        % Cell structure: Each element is a sub-cell like {{'Pnode', ID1}, {'Wedge', ID2}, ...}
        for i = 1:numel(InvalidRule)
            forbiddenSet = InvalidRule{i};
            hitCount = 0;  % Count of components in forbiddenSet that are attacked
            for j = 1:numel(forbiddenSet)
                compType = forbiddenSet{j}{1};
                compID = forbiddenSet{j}{2};
                attackedIDs = pick_ids(S, compType);
                hitCount = hitCount + ismember(compID, attackedIDs);
            end
            % Violation if all components in the forbidden set are attacked
            if hitCount == numel(forbiddenSet)
                ok = false;
                return;
            end
        end
    end
catch
    % Ignore invalid rules if parsing fails (issue a warning to inform the user)
    warning('Failed to parse InvalidStrategy rules. Skipping invalid combination checks.');
end
end

function Sids = pick_ids(S, compType)
% pick_ids: Extract IDs of attacked components for a specified type from the strategy structure
% Inputs:
%   - S: Structured attack strategy
%   - compType: Component type to extract ('Pnode', 'Pedge', 'Wnode', 'Wedge')
% Output:
%   - Sids: IDs of attacked components of the specified type (empty if none)
switch compType
    case 'Pnode'
        Sids = S.Power.Node;
    case 'Pedge'
        Sids = S.Power.Edge;
    case 'Wnode'
        Sids = S.Water.Node;
    case 'Wedge'
        Sids = S.Water.Edge;
    otherwise
        Sids = [];  % Return empty array for unrecognized component types
end
end

function x = fix_invalid_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidRule)
% fix_invalid_rules: Repair an invalid attack vector by randomly removing attacked components
% Inputs:
%   - x: Invalid binary attack vector
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
%   - InvalidRule: Invalid strategy rules (used to check validity post-repair)
% Output:
%   - x: Valid binary attack vector (or original if repair fails after 20 attempts)
% Exit early if no invalid rules are defined
if isempty(InvalidRule)
    return;
end

iter = 0;
maxIter = 20;  % Limit iterations to avoid infinite loops
% Keep removing random attacked components until valid or max iterations are reached
while ~is_valid_with_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidRule) && iter < maxIter
    % Get indices of attacked components (cannot repair if no components are attacked)
    attackedIdx = find(x);
    if isempty(attackedIdx)
        break;
    end
    % Randomly select and remove one attacked component
    j = attackedIdx(randi(numel(attackedIdx)));
    x(j) = false;
    iter = iter + 1;
end
end

function x_new = neighbor(x, canAttack, cost, B, idx)
% neighbor: Generate a new neighborhood solution from the current attack vector
% Inputs:
%   - x: Current binary attack vector
%   - canAttack: Mask of attackable components (true = allowed to attack)
%   - cost: Global array of attack costs
%   - B: Total allowable attack budget
%   - idx: Structure of global indices (unused here, retained for function signature consistency)
% Output:
%   - x_new: New neighborhood solution (budget-feasible after repair)
x_new = x;
% Randomly select a neighborhood operation (1=add, 2=drop, 3=swap)
opType = randi(3);

% Get indices of attacked components and available (attackable but not attacked) components
attackedIdx = find(x);
availableIdx = find(~x & canAttack);

switch opType
    case 1  % Add operation: Attack one additional available component
        if ~isempty(availableIdx)
            x_new(availableIdx(randi(numel(availableIdx)))) = true;
        end
    case 2  % Drop operation: Stop attacking one already attacked component
        if ~isempty(attackedIdx)
            x_new(attackedIdx(randi(numel(attackedIdx)))) = false;
        end
    case 3  % Swap operation: Replace one attacked component with one available component
        if ~isempty(attackedIdx) && ~isempty(availableIdx)
            x_new(attackedIdx(randi(numel(attackedIdx)))) = false;
            x_new(availableIdx(randi(numel(availableIdx)))) = true;
        end
end

% Repair the new solution to ensure it stays within the budget
x_new = repair_budget(x_new, cost, B, idx);
end

function [PfunLoss, WfunLoss, J] = evaluate_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
    PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams)
% evaluate_strategy: Compute system functionality losses and objective function J for an attack vector
% Inputs:
%   - x: Binary attack vector (empty = no components attacked)
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
%   - PowerSystem/WaterSystem: System data structures
%   - PowerWaterInterdependency: Structure defining power-water interdependencies
%   - OperatorParams: Operational parameters for functionality evaluation
% Outputs:
%   - PfunLoss: 1x3 power system functionality metrics [loss, post-attack func, initial func]
%   - WfunLoss: 1x3 water system functionality metrics [loss, post-attack func, initial func]
%   - J: Objective function value (sum of normalized remaining functionalities)

% Handle empty attack vector (initialize to all false if x is empty)
if isempty(x)
    x = false(1, idx.Wedge(end));
end

% Get global indices of attacked components
attackedGlobalIdx = find(x);

% Map global attacked indices to original component IDs for each system
% Power system: Map to node/edge IDs and format as [DamageType, ID] (1=node, 2=edge)
selPN = intersect(attackedGlobalIdx, idx.Pnode);
idsPN = PnodeID(ismember(1:numel(PnodeID), selPN - idx.Pnode(1) + 1));
selPE = intersect(attackedGlobalIdx, idx.Pedge);
idsPE = PedgeID(ismember(1:numel(PedgeID), selPE - idx.Pedge(1) + 1));
PowerComDamgScenario = [repmat(1, numel(idsPN), 1), idsPN(:); repmat(2, numel(idsPE), 1), idsPE(:)];

% Water system: Map to node/edge IDs and format as [DamageType, ID] (1=node, 2=edge)
selWN = intersect(attackedGlobalIdx, idx.Wnode);
idsWN = WnodeID(ismember(1:numel(WnodeID), selWN - idx.Wnode(1) + 1));
selWE = intersect(attackedGlobalIdx, idx.Wedge);
idsWE = WedgeID(ismember(1:numel(WedgeID), selWE - idx.Wedge(1) + 1));
WaterComDamgScenario = [repmat(1, numel(idsWN), 1), idsWN(:); repmat(2, numel(idsWE), 1), idsWE(:)];

% Call external function to compute post-attack functionality losses
[PfunLoss, WfunLoss] = GlobalOptPowerMFWaterMF( ...
    PowerSystem, WaterSystem, PowerWaterInterdependency, ...
    PowerComDamgScenario, WaterComDamgScenario, TerminalZone, OperatorParams);

% Compute normalized remaining functionality (use eps to avoid division by zero)
normPower = safe_div(PfunLoss(2), max(PfunLoss(3), eps));  % Post-attack / Initial power func
normWater = safe_div(WfunLoss(2), max(WfunLoss(3), eps));  % Post-attack / Initial water func

% Calculate objective function J (smaller = more severe attack)
J = normPower + normWater;
end

function val = safe_div(a, b)
% safe_div: Perform division with protection against division by zero
% Inputs:
%   - a: Numerator
%   - b: Denominator
% Output:
%   - val: a/b if b ¡Ù 0, otherwise 0
if b == 0
    val = 0;
else
    val = a / b;
end
end

function S = vec_to_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID)
% vec_to_strategy: Convert a binary attack vector to a structured attack strategy (human-readable)
% Inputs:
%   - x: Binary attack vector (true = component is attacked)
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
% Output:
%   - S: Structured attack strategy with attacked component IDs
% Initialize empty strategy structure
S = empty_strategy();

% Map power system components from binary vector to IDs
if any(x(idx.Pnode))
    attackMask = logical(x(idx.Pnode));
    S.Power.Node = PnodeID(attackMask);
end
if any(x(idx.Pedge))
    attackMask = logical(x(idx.Pedge));
    S.Power.Edge = PedgeID(attackMask);
end

% Map water system components from binary vector to IDs
if any(x(idx.Wnode))
    attackMask = logical(x(idx.Wnode));
    S.Water.Node = WnodeID(attackMask);
end
if any(x(idx.Wedge))
    attackMask = logical(x(idx.Wedge));
    S.Water.Edge = WedgeID(attackMask);
end
end