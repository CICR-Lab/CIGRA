function [AttackStrategy, PowerSysFunLoss, GasSysFunLoss] = ...
    NLcAttacterRobPowerMFGasMFOperator(PowerSystem, GasSystem, PowerGasInterdependency, OperatorParams, AttackParams, TerminalZone, SAParams)
% NLcAttacterRobPowerMFGasMFOperator: Search for worst-case attack strategy on integrated power-gas systems
% 
% Purpose: Use Simulated Annealing (SA) to identify the most destructive attack strategy for the 
%          power-gas interdependent system under budget constraints. The core goal is to minimize 
%          the normalized total remaining functionality of the two systems.
% 
% Algorithm: The objective function J is defined as the sum of normalized remaining functionalities 
%            of the power and gas systems:
%            J = (Post-attack Power Functionality / Initial Power Functionality) + 
%                (Post-attack Gas Functionality / Initial Gas Functionality)
%            A smaller J value indicates a more severe (worst-case) attack. System functionality 
%            is evaluated by calling the pre-implemented function GlobalOptRobPowerMFGasMF.
% 
% Input Arguments:
%   - PowerSystem: Structure containing power system data (includes Nodes and Edges with unique IDs 
%                  and operational parameters like capacity and connectivity)
%   - GasSystem: Structure containing gas system data (includes Nodes and Edges with unique IDs 
%                  and operational parameters like flow limits and pump settings)
%   - PowerGasInterdependency: Structure defining interdependent relationships between the power 
%                                and gas systems (e.g., power supply required for gas distribution pumps)
%   - OperatorParams: Structure with operational parameters for evaluating post-attack system functionality 
%                     (e.g., load priority, flow balancing constraints)
%   - AttackParams: Structure with attack-related configuration (mandatory and optional fields):
%     - Budget: Total allowable cost for the attack (mandatory; throws error if missing)
%     - PowerNodeAttackCost/PowerEdgeAttackCost: Cost to attack power system nodes/edges (default = 1 per component)
%     - GasNodeAttackCost/GasEdgeAttackCost: Cost to attack gas system nodes/edges (default = 1 per component)
%     - InvulPowerNode/InvulPowerEdge: IDs of invulnerable power components (cannot be attacked; auto-deduplicated)
%     - InvulGasNode/InvulGasEdge: IDs of invulnerable gas components (cannot be attacked; auto-deduplicated)
%     - InvalidStrategy: Optional rules to exclude unrealistic attack combinations (supports function handle, 
%                        struct array, or cell array format)
%   - SAParams: Structure with Simulated Annealing algorithm parameters (defaults provided if missing):
%     - T0: Initial temperature (default = 1.0)
%     - alpha: Temperature cooling rate (default = 0.90; reduces T by 10% per cycle)
%     - L: Number of iterations (neighborhood searches) per temperature level (default = 50)
%     - Tmin: Minimum temperature to terminate the algorithm (default = 1e-3)
%     - MaxNoImprove: Maximum iterations without improving the best solution (default = 300)
% 
% Output Arguments:
%   - AttackStrategy: Structured attack strategy with human-readable component IDs:
%     - AttackStrategy.Power.Node: IDs of power system nodes targeted by the attack
%     - AttackStrategy.Power.Edge: IDs of power system edges targeted by the attack
%     - AttackStrategy.Gas.Node: IDs of gas system nodes targeted by the attack
%     - AttackStrategy.Gas.Edge: IDs of gas system edges targeted by the attack
%   - PowerSysFunLoss: 1x3 vector of power system functionality metrics:
%     - PowerSysFunLoss(1): Functionality loss (initial - post-attack)
%     - PowerSysFunLoss(2): Remaining functionality after the attack
%     - PowerSysFunLoss(3): Initial functionality before the attack
%   - GasSysFunLoss: 1x3 vector of gas system functionality metrics (same structure as PowerSysFunLoss)
% 
% Key Implementation Notes:
%   1. Unified component coding: Maps 4 component types (Pnode, Pedge, Gnode, Gedge) to non-overlapping 
%      global indices for centralized processing and budget management.
%   2. Constraint handling: Supports invulnerable component sets and invalid attack rules to avoid 
%      physically unrealistic or unintended strategies.
%   3. Neighborhood generation: Uses 3 operations (add/drop/swap) to explore solution space, with 
%      automatic budget repair to ensure all candidates are feasible.
%   4. Evaluation caching: Uses containers.Map to store results of previously evaluated strategies, 
%      eliminating redundant MILP (Mixed-Integer Linear Programming) computations.
%   5. Objective direction: Smaller J values correspond to more severe attacks; SA accepts both better 
%      and worse solutions (via Metropolis criterion) to escape local optima.
% 
% Author: Generated by ChatGPT

%% ------------------------ 0. Safety & Default Parameter Initialization ------------------------
% Initialize random number generator for reproducible random component selection
rng('shuffle');

% Set default SA parameters if SAParams is missing or empty
if nargin  < 7 || isempty(SAParams)
    SAParams = struct();
end
% Default SA parameter template (balances exploration and convergence)
defSA = struct('T0', 1.0, 'alpha', 0.90, 'L', 50, 'Tmin', 1e-3, 'MaxNoImprove', 300);
SAParams = apply_default(SAParams, defSA);

% Initialize attack parameters (budget, costs, constraints) if missing
if nargin < 5 || isempty(AttackParams)
    AttackParams = struct();
end
% Enforce mandatory budget field (critical for attack feasibility; throw error if missing)
if ~isfield(AttackParams, 'Budget')
    error('AttackParams must contain the mandatory ''Budget'' field (total allowable attack cost).');
end

% Extract unique IDs of all components from power and gas systems
PnodeID = [PowerSystem.Node.ID];      Np = numel(PnodeID);  % Count of power system nodes
PedgeID = [PowerSystem.Edge.ID];      Ep = numel(PedgeID);  % Count of power system edges
GnodeID = [GasSystem.Node.ID];      Ng = numel(GnodeID);  % Count of gas system nodes
GedgeID = [GasSystem.Edge.ID];      Eg = numel(GedgeID);  % Count of gas system edges

% Get attack costs for each component (use default 1 if not specified in AttackParams)
% Validate cost vector length to match component counts (avoids mismatches)
cPnode = get_or_default(AttackParams, 'PowerNodeAttackCost', ones(1, Np), Np);
cPedge = get_or_default(AttackParams, 'PowerEdgeAttackCost', ones(1, Ep), Ep);
cGnode = get_or_default(AttackParams, 'GasNodeAttackCost', ones(1, Ng), Ng);
cGedge = get_or_default(AttackParams, 'GasEdgeAttackCost', ones(1, Eg), Eg);

% Define invulnerable components (cannot be attacked) - deduplicate IDs to remove duplicates
invPN = unique(get_or_default(AttackParams, 'InvulPowerNode', [], 0));  % Invulnerable power nodes
invPE = unique(get_or_default(AttackParams, 'InvulPowerEdge', [], 0));  % Invulnerable power edges
invGN = unique(get_or_default(AttackParams, 'InvulGasNode', [], 0));  % Invulnerable gas nodes
invGE = unique(get_or_default(AttackParams, 'InvulGasEdge', [], 0));  % Invulnerable gas edges

% Initialize invalid attack strategies (optional rules to exclude specific combinations)
InvalidStrategy = [];
if isfield(AttackParams, 'InvalidStrategy') && ~isempty(AttackParams.InvalidStrategy)
    InvalidStrategy = AttackParams.InvalidStrategy;
end

% Extract total attack budget (finalize after parameter initialization)
Budget = AttackParams.Budget;

%% ------------------------ 1. Unified Coding & Feasible Region Definition ------------------------
% Map 4 component types to non-overlapping global indices (1-based) for centralized processing
idx.Pnode = 1:Np;                          % Global indices for power nodes
idx.Pedge = Np + (1:Ep);                   % Global indices for power edges
idx.Gnode = Np + Ep + (1:Ng);              % Global indices for gas nodes
idx.Gedge = Np + Ep + Ng + (1:Eg);         % Global indices for gas edges
Ntot = Np + Ep + Ng + Eg;                  % Total number of components across both systems

% Build global cost array (maps each component's cost to its global index)
cost = zeros(1, Ntot);
cost(idx.Pnode) = cPnode;
cost(idx.Pedge) = cPedge;
cost(idx.Gnode) = cGnode;
cost(idx.Gedge) = cGedge;

% Create binary mask for attackable components (true = allowed to attack; false = invulnerable)
canAttack = true(1, Ntot);
% Mark invulnerable components as unattackable by matching their IDs to global indices
canAttack(idx.Pnode(ismember(PnodeID, invPN))) = false;
canAttack(idx.Pedge(ismember(PedgeID, invPE))) = false;
canAttack(idx.Gnode(ismember(GnodeID, invGN))) = false;
canAttack(idx.Gedge(ismember(GedgeID, invGE))) = false;

% Handle non-positive attack costs (invalid, as costs cannot be zero/negative)
if any(cost <= 0)
    warnIdx = find(cost <= 0);
    warning('Non-positive attack costs detected. Marked %d components as unattackable.', numel(warnIdx));
    canAttack(warnIdx) = false;
    cost(warnIdx) = inf;  % Set cost to infinity to prevent accidental selection
end

% Get indices of feasible attack candidates (only components marked as attackable)
candIdx = find(canAttack);
% Edge case: No attackable components available (return empty strategy immediately)
if isempty(candIdx)
    warning('No attackable components found. Returning empty attack strategy.');
    AttackStrategy = empty_strategy();
    [PowerSysFunLoss, GasSysFunLoss] = evaluate_strategy([], idx, PnodeID, PedgeID, GnodeID, GedgeID, ...
        PowerSystem, GasSystem, PowerGasInterdependency, TerminalZone, OperatorParams);
    return;
end

%% ------------------------ 2. Initial Solution Generation (Random Feasible) ------------------------
x = false(1, Ntot);  % Binary vector: true = component is attacked, false = not attacked
% Shuffle candidate components to ensure randomness in initial solution selection
candShuffled = candIdx(randperm(numel(candIdx)));
remainB = Budget;    % Remaining budget for building the initial solution

% Construct initial solution by adding components within budget (check invalid rules)
for k = 1:numel(candShuffled)
    j = candShuffled(k);
    % Only select the component if its cost is within the remaining budget
    if cost(j) <= remainB
        x(j) = true;
        % Revert selection if it violates invalid attack strategy rules
        if ~is_valid_with_rules(x, idx, PnodeID, PedgeID, GnodeID, GedgeID, InvalidStrategy)
            x(j) = false;
        else
            remainB = remainB - cost(j);  % Update remaining budget after valid selection
        end
    end
end
% Final budget repair: Ensure initial solution does not exceed the total budget
x = repair_budget(x, cost, Budget, idx);

% Evaluate the initial solution to get functionality losses and objective value J
[PowerSysFunLoss, GasSysFunLoss, Jx] = ...
    evaluate_strategy(x, idx, PnodeID, PedgeID, GnodeID, GedgeID, ...
        PowerSystem, GasSystem, PowerGasInterdependency, TerminalZone, OperatorParams);

% Initialize tracker for the best solution found so far
best.x   = x;               % Best attack selection vector
best.J   = Jx;              % Best objective value (smallest = worst attack)
best.FPL = PowerSysFunLoss; % Best power system functionality loss
best.FGL = GasSysFunLoss; % Best gas system functionality loss

%% ------------------------ 3. Simulated Annealing Main Loop ------------------------
% Extract SA algorithm parameters from the structured input
T        = SAParams.T0;          % Initial temperature (controls exploration)
L        = SAParams.L;           % Number of iterations per temperature level
alp      = SAParams.alpha;       % Temperature cooling rate (T = T * alp each cycle)
Tmin     = SAParams.Tmin;        % Minimum temperature to terminate the algorithm
maxNoImp = SAParams.MaxNoImprove;% Maximum iterations without improving the best solution
noImpCount = 0;                  % Counter for iterations without improvement

% Initialize evaluation cache: Stores J and functionality losses for existing strategies
% Reduces redundant calls to the computationally expensive MILP evaluation function
eval_cache = containers.Map('KeyType', 'char', 'ValueType', 'any');

% Cache the evaluation results of the initial solution
key = key_of(x);
eval_cache(key) = {Jx, PowerSysFunLoss, GasSysFunLoss};

% Main SA loop: Run until temperature drops below Tmin or no improvement for maxNoImp cycles
while T > Tmin && noImpCount < maxNoImp
    improved_in_T = false;  % Flag to track if the best solution is improved in current temperature level

    % Perform L iterations (neighborhood searches) at the current temperature
    for it = 1:L
        % Generate a new neighborhood solution using add/drop/swap operations
        x_new = neighbor(x, canAttack, cost, Budget, idx);

        % Check if the new solution violates invalid rules; repair if necessary
        if ~is_valid_with_rules(x_new, idx, PnodeID, PedgeID, GnodeID, GedgeID, InvalidStrategy)
            % Simple repair: Randomly remove one attacked component to resolve invalidity
            x_new = fix_invalid_rules(x_new, idx, PnodeID, PedgeID, GnodeID, GedgeID, InvalidStrategy);
        end
        % Ensure the new solution is budget-feasible (critical for validity)
        x_new = repair_budget(x_new, cost, Budget, idx);

        % Generate a unique key for cache lookup (based on attacked component indices)
        key = key_of(x_new);
        % Retrieve cached results if available; compute new results otherwise
        if isKey(eval_cache, key)
            val = eval_cache(key);
            Jnew = val{1};       % Objective value of the new solution
            Pnew = val{2};       % Power system functionality loss of the new solution
            Gnew = val{3};       % Gas system functionality loss of the new solution
        else
            % Evaluate the new solution if not in cache
            [Pnew, Gnew, Jnew] = evaluate_strategy(x_new, idx, PnodeID, PedgeID, GnodeID, GedgeID, ...
                PowerSystem, GasSystem, PowerGasInterdependency, TerminalZone, OperatorParams);
            % Store the new evaluation results in cache for future use
            eval_cache(key) = {Jnew, Pnew, Gnew};
        end

        % Metropolis criterion: Decide whether to accept the new solution
        dJ = Jnew - Jx;  % Difference in objective value (dJ < 0 = better solution)
        % Accept better solutions (dJ < 0) or worse solutions with probability exp(-dJ/T)
        if dJ < 0 || rand < exp(-dJ / max(T, eps))
            % Update current solution to the accepted new solution
            x = x_new;
            Jx = Jnew;
            PowerSysFunLoss = Pnew;
            GasSysFunLoss = Gnew;

            % Update the best solution if the current solution is significantly better (numerical tolerance)
            if Jx < best.J - 1e-12
                best.x = x;
                best.J = Jx;
                best.FPL = PowerSysFunLoss;
                best.FGL = GasSysFunLoss;
                improved_in_T = true;  % Mark that improvement occurred in this temperature level
            end
        end
    end

    % Cool down the temperature for the next cycle (reduces exploration over time)
    T = T * alp;
    % Update no-improvement counter: Reset if improved, increment otherwise
    if improved_in_T
        noImpCount = 0;
    else
        noImpCount = noImpCount + 1;
    end
end

%% ------------------------ 4. Output Optimal Solution ------------------------
% Convert the best binary attack vector to a structured, human-readable strategy
AttackStrategy = vec_to_strategy(best.x, idx, PnodeID, PedgeID, GnodeID, GedgeID);
% Extract the functionality losses from the best solution for output
PowerSysFunLoss = best.FPL;
GasSysFunLoss = best.FGL;

end

%% ====================== Helper Function Section ======================
function S = empty_strategy()
% empty_strategy: Create an empty attack strategy structure (no components attacked)
% Output:
%   - S: Empty strategy structure with fields for power and gas system components
S.Power.Node = [];
S.Power.Edge = [];
S.Gas.Node = [];
S.Gas.Edge = [];
end

function SA = apply_default(SA, DEF)
% apply_default: Fill missing or empty fields in the SA parameter structure with defaults
% Inputs:
%   - SA: Input SA structure (may have missing/empty fields)
%   - DEF: Structure containing default values for all required SA fields
% Output:
%   - SA: Updated SA structure with missing fields populated by defaults
fns = fieldnames(DEF);
for i = 1:numel(fns)
    f = fns{i};
    % Set field to default if it is missing or empty
    if ~isfield(SA, f) || isempty(SA.(f))
        SA.(f) = DEF.(f);
    end
end
end

function v = get_or_default(st, fname, defv, expectLen)
% get_or_default: Retrieve a value from a structure field, or use a default if missing/empty
% Inputs:
%   - st: Input structure to query for the field
%   - fname: Name of the field to retrieve
%   - defv: Default value to use if the field is missing or empty
%   - expectLen: Expected length of the value (0 = skip length validation)
% Output:
%   - v: Retrieved field value or default value (throws error if length mismatch)
if isfield(st, fname) && ~isempty(st.(fname))
    v = st.(fname);
else
    v = defv;
end
% Validate value length if required (ensures consistency with component counts)
if expectLen > 0 && numel(v) ~= expectLen
    error('Field ''%s'' length mismatch: Expected %d elements, got %d.', fname, expectLen, numel(v));
end
end

function key = key_of(x)
% key_of: Generate a unique string key for a binary attack vector (used for cache lookup)
% Input:
%   - x: Binary vector representing the attack strategy (true = attacked)
% Output:
%   - key: Comma-separated string of indices of attacked components (empty vector = '[]')
idx = find(x);
if isempty(idx)
    key = '[]';
    return;
end
key = sprintf('%d,', idx);
end

function x = repair_budget(x, cost, B, idx)
% repair_budget: Ensure an attack vector stays within the total budget by removing high-cost components
% Inputs:
%   - x: Binary attack vector (may exceed the budget)
%   - cost: Global array of attack costs for all components
%   - B: Total allowable attack budget
%   - idx: Structure of global indices (unused here, retained for function signature consistency)
% Output:
%   - x: Budget-feasible binary attack vector
% Exit early if the current vector is already within budget
totalCost = sum(cost(x));
if totalCost <= B
    return;
end
% Get indices of currently attacked components
attackedIdx = find(x);
% Sort attacked components by cost (descending): Remove most expensive first for efficiency
[~, sortedCostIdx] = sort(cost(attackedIdx), 'descend');
% Remove components one by one until the budget constraint is satisfied
for k = 1:numel(sortedCostIdx)
    x(attackedIdx(sortedCostIdx(k))) = false;
    if sum(cost(x)) <= B
        break;
    end
end
end

function ok = is_valid_with_rules(x, idx, PnodeID, PedgeID, GnodeID, GedgeID, InvalidRule)
% is_valid_with_rules: Check if an attack vector violates the specified invalid strategy rules
% Inputs:
%   - x: Binary attack vector to validate
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - GnodeID/GedgeID: Gas system node/edge IDs
%   - InvalidRule: Invalid strategy rules (3 supported formats: function handle, struct array, cell array)
% Output:
%   - ok: true = valid (no rule violation), false = invalid
ok = true;
% Exit early if no invalid rules are defined
if isempty(InvalidRule)
    return;
end

% Convert the binary vector to a structured attack strategy for rule checking
S = vec_to_strategy(x, idx, PnodeID, PedgeID, GnodeID, GedgeID);

% Case 1: InvalidRule is a function handle (returns true if the strategy is invalid)
if isa(InvalidRule, 'function_handle')
    ok = ~InvalidRule(S);  % Invert result: Function returns true = invalid ¡ú ok = false
    return;
end

% Case 2: InvalidRule is a struct array or cell array (use try-catch for robustness)
try
    if isstruct(InvalidRule)
        % Struct array format: Each struct defines mutually exclusive components of the same type
        % Struct fields: .Type (component type, e.g., 'Pnode'), .IDs (mutually exclusive component IDs)
        for i = 1:numel(InvalidRule)
            compType = InvalidRule(i).Type;
            exclIDs = InvalidRule(i).IDs(:)';
            % Get IDs of attacked components of the specified type
            attackedIDs = pick_ids(S, compType);
            % Violation if 2+ mutually exclusive components are attacked
            if numel(intersect(attackedIDs, exclIDs)) >= 2
                ok = false;
                return;
            end
        end
    elseif iscell(InvalidRule)
        % Cell array format: Each cell defines a set of components that cannot all be attacked
        % Cell structure: Each element is a sub-cell like {{'Pnode', ID1}, {'Wedge', ID2}, ...}
        for i = 1:numel(InvalidRule)
            forbiddenSet = InvalidRule{i};
            hitCount = 0;  % Count of components in forbiddenSet that are attacked
            for j = 1:numel(forbiddenSet)
                compType = forbiddenSet{j}{1};
                compID = forbiddenSet{j}{2};
                attackedIDs = pick_ids(S, compType);
                hitCount = hitCount + ismember(compID, attackedIDs);
            end
            % Violation if all components in the forbidden set are attacked
            if hitCount == numel(forbiddenSet)
                ok = false;
                return;
            end
        end
    end
catch
    % Ignore invalid rules if parsing fails (issue a warning to inform the user)
    warning('Failed to parse InvalidStrategy rules. Skipping invalid combination checks.');
end
end

function Sids = pick_ids(S, compType)
% pick_ids: Extract IDs of attacked components for a specified type from the strategy structure
% Inputs:
%   - S: Structured attack strategy
%   - compType: Component type to extract ('Pnode', 'Pedge', 'Wnode', 'Wedge')
% Output:
%   - Sids: IDs of attacked components of the specified type (empty if none)
switch compType
    case 'Pnode'
        Sids = S.Power.Node;
    case 'Pedge'
        Sids = S.Power.Edge;
    case 'Gnode'
        Sids = S.Gas.Node;
    case 'Gedge'
        Sids = S.Gas.Edge;
    otherwise
        Sids = [];  % Return empty array for unrecognized component types
end
end

function x = fix_invalid_rules(x, idx, PnodeID, PedgeID, GnodeID, GedgeID, InvalidRule)
% fix_invalid_rules: Repair an invalid attack vector by randomly removing attacked components
% Inputs:
%   - x: Invalid binary attack vector
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Gas system node/edge IDs
%   - InvalidRule: Invalid strategy rules (used to check validity post-repair)
% Output:
%   - x: Valid binary attack vector (or original if repair fails after 20 attempts)
% Exit early if no invalid rules are defined
if isempty(InvalidRule)
    return;
end

iter = 0;
maxIter = 20;  % Limit iterations to avoid infinite loops
% Keep removing random attacked components until valid or max iterations are reached
while ~is_valid_with_rules(x, idx, PnodeID, PedgeID, GnodeID, GedgeID, InvalidRule) && iter < maxIter
    % Get indices of attacked components (cannot repair if no components are attacked)
    attackedIdx = find(x);
    if isempty(attackedIdx)
        break;
    end
    % Randomly select and remove one attacked component
    j = attackedIdx(randi(numel(attackedIdx)));
    x(j) = false;
    iter = iter + 1;
end
end

function x_new = neighbor(x, canAttack, cost, B, idx)
% neighbor: Generate a new neighborhood solution from the current attack vector
% Inputs:
%   - x: Current binary attack vector
%   - canAttack: Mask of attackable components (true = allowed to attack)
%   - cost: Global array of attack costs
%   - B: Total allowable attack budget
%   - idx: Structure of global indices (unused here, retained for function signature consistency)
% Output:
%   - x_new: New neighborhood solution (budget-feasible after repair)
x_new = x;
% Randomly select a neighborhood operation (1=add, 2=drop, 3=swap)
opType = randi(3);

% Get indices of attacked components and available (attackable but not attacked) components
attackedIdx = find(x);
availableIdx = find(~x & canAttack);

switch opType
    case 1  % Add operation: Attack one additional available component
        if ~isempty(availableIdx)
            x_new(availableIdx(randi(numel(availableIdx)))) = true;
        end
    case 2  % Drop operation: Stop attacking one already attacked component
        if ~isempty(attackedIdx)
            x_new(attackedIdx(randi(numel(attackedIdx)))) = false;
        end
    case 3  % Swap operation: Replace one attacked component with one available component
        if ~isempty(attackedIdx) && ~isempty(availableIdx)
            x_new(attackedIdx(randi(numel(attackedIdx)))) = false;
            x_new(availableIdx(randi(numel(availableIdx)))) = true;
        end
end

% Repair the new solution to ensure it stays within the budget
x_new = repair_budget(x_new, cost, B, idx);
end

function [PfunLoss, GfunLoss, J] = evaluate_strategy(x, idx, PnodeID, PedgeID, GnodeID, GedgeID, ...
    PowerSystem, GasSystem, PowerGasInterdependency, TerminalZone, OperatorParams)
% evaluate_strategy: Compute system functionality losses and objective function J for an attack vector
% Inputs:
%   - x: Binary attack vector (empty = no components attacked)
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Gas system node/edge IDs
%   - PowerSystem/GasSystem: System data structures
%   - PowerGasInterdependency: Structure defining power-gas interdependencies
%   - OperatorParams: Operational parameters for functionality evaluation
% Outputs:
%   - PfunLoss: 1x3 power system metrics [loss, post-attack func, initial func]
%   - WfunLoss: 1x3 gas system metrics [loss, post-attack func, initial func]
%   - J: Objective function value (sum of normalized remaining functionalities)

% Handle empty attack vector (initialize to all false if x is empty)
if isempty(x)
    x = false(1, idx.Gedge(end));
end

% Get global indices of attacked components
attackedGlobalIdx = find(x);

% Map global attacked indices to original component IDs and format damage scenarios
% Damage scenario format: [DamageType, ComponentID] (1 = node, 2 = edge)
% Power system damage scenario
selPN = intersect(attackedGlobalIdx, idx.Pnode);
idsPN = PnodeID(ismember(1:numel(PnodeID), selPN - idx.Pnode(1) + 1));
selPE = intersect(attackedGlobalIdx, idx.Pedge);
idsPE = PedgeID(ismember(1:numel(PedgeID), selPE - idx.Pedge(1) + 1));
PowerComDamgScenario = [repmat(1, numel(idsPN), 1), idsPN(:); repmat(2, numel(idsPE), 1), idsPE(:)];

% Gas system damage scenario
selGN = intersect(attackedGlobalIdx, idx.Gnode);
idsGN = GnodeID(ismember(1:numel(GnodeID), selGN - idx.Gnode(1) + 1));
selGE = intersect(attackedGlobalIdx, idx.Gedge);
idsGE = GedgeID(ismember(1:numel(GedgeID), selGE - idx.Gedge(1) + 1));
GasComDamgScenario = [repmat(1, numel(idsGN), 1), idsGN(:); repmat(2, numel(idsGE), 1), idsGE(:)];

% Call external function to compute post-attack functionality losses
[PfunLoss, GfunLoss] = GlobalOptPowerMFGasMF( ...
    PowerSystem, GasSystem, PowerGasInterdependency, ...
    PowerComDamgScenario, GasComDamgScenario, TerminalZone, OperatorParams);

% Compute normalized remaining functionality (use eps to avoid division by zero)
normPower = safe_div(PfunLoss(2), max(PfunLoss(3), eps));  % Post-attack / Initial power func
normGas = safe_div(GfunLoss(2), max(GfunLoss(3), eps));  % Post-attack / Initial gas func

% Calculate objective function J (smaller = more severe attack)
J = normPower + normGas;
end

function val = safe_div(a, b)
% safe_div: Perform division with protection against division by zero
% Inputs:
%   - a: Numerator
%   - b: Denominator
% Output:
%   - val: a/b if b ¡Ù 0, otherwise 0
if b == 0
    val = 0;
else
    val = a / b;
end
end

function S = vec_to_strategy(x, idx, PnodeID, PedgeID, GnodeID, GedgeID)
% vec_to_strategy: Convert a binary attack vector to a structured, human-readable strategy
% Inputs:
%   - x: Binary attack vector (true = component is attacked)
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - GnodeID/WedgeID: Gas system node/edge IDs
% Output:
%   - S: Structured attack strategy with attacked component IDs
% Initialize empty strategy structure
S = empty_strategy();

% Map power system components from binary vector to IDs
if any(x(idx.Pnode))
    attackMask = logical(x(idx.Pnode));
    S.Power.Node = PnodeID(attackMask);
end
if any(x(idx.Pedge))
    attackMask = logical(x(idx.Pedge));
    S.Power.Edge = PedgeID(attackMask);
end

% Map gas system components from binary vector to IDs
if any(x(idx.Gnode))
    attackMask = logical(x(idx.Gnode));
    S.Gas.Node = GnodeID(attackMask);
end
if any(x(idx.Gedge))
    attackMask = logical(x(idx.Gedge));
    S.Gas.Edge = GedgeID(attackMask);
end
end