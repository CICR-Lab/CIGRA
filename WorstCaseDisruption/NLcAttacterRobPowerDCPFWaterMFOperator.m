function [AttackStrategy, PowerSysFunLoss, WaterSysFunLoss] = ...
    NLcAttacterRobPowerDCPFWaterMFOperator(PowerSystem, WaterSystem, PowerWaterInterdependency, OperatorParams, AttackParams, TerminalZone, SAParams)
% NLcAttacterRobPowerDCPFWaterMFOperator: Search for worst-case attack strategy on integrated power-water systems
% 
% Purpose: Use Simulated Annealing (SA) to identify the most destructive attack strategy for the 
%          power-water interdependent system under budget constraints. The goal is to minimize the 
%          normalized remaining functionality of the two systems.
% 
% Algorithm: The objective function J is defined as the sum of normalized remaining functionalities:
%            J = (Post-attack Power Functionality / Initial Power Functionality) + 
%                (Post-attack Water Functionality / Initial Water Functionality)
%            A smaller J indicates a more severe (worst-case) attack. System functionality is 
%            evaluated by calling the pre-built function GlobalOptRobPowerDCPFWaterMF.
% 
% Input Arguments:
%   - PowerSystem: Structure containing power system data (Nodes and Edges with unique IDs and parameters)
%   - WaterSystem: Structure containing water system data (Nodes and Edges with unique IDs and parameters)
%   - PowerWaterInterdependency: Structure defining interdependencies between the power and water systems
%   - OperatorParams: Structure with operational parameters for system functionality evaluation
%   - AttackParams: Structure with attack-related parameters (Budget, component attack costs, 
%                   invulnerable components, invalid attack strategies)
%   - SAParams: Structure with SA algorithm parameters (initial temperature T0, cooling rate alpha, 
%               iterations per temperature L, minimum temperature Tmin, max no-improve iterations)
% 
% Output Arguments:
%   - AttackStrategy: Structure specifying the optimal attack targets:
%     - AttackStrategy.Power.Node: IDs of attacked power nodes
%     - AttackStrategy.Power.Edge: IDs of attacked power edges
%     - AttackStrategy.Water.Node: IDs of attacked water nodes
%     - AttackStrategy.Water.Edge: IDs of attacked water edges
%   - PowerSysFunLoss: 1x3 vector of power system functionality metrics [functionality loss, 
%                      post-attack functionality, initial functionality]
%   - WaterSysFunLoss: 1x3 vector of water system functionality metrics [functionality loss, 
%                      post-attack functionality, initial functionality]
% 
% Key Implementation Notes:
%   1. Unified component coding: Maps 4 component types (Pnode, Pedge, Wnode, Wedge) to global indices
%   2. Constraint support: Handles invulnerable component sets and optional invalid attack combinations
%   3. Neighborhood generation: Uses add/drop/swap operations (with automatic budget repair for feasibility)
%   4. Evaluation caching: Uses containers.Map to avoid redundant MILP (Mixed-Integer Linear Programming) calls
%   5. Objective direction: Smaller J values represent more severe attacks; SA accepts both better and 
%      worse solutions (per Metropolis criterion) to avoid local optima
% 
% Author: Generated by ChatGPT

%% ------------------------ 0. Safety & Default Parameter Initialization ------------------------
% Initialize random number generator for reproducible random selections
rng('shuffle');

% Set default SA parameters if SAParams is missing or empty
if nargin < 7 || isempty(SAParams)
    SAParams = struct();
end
% Default SA parameter set: T0=initial temp, alpha=cooling rate, L=iterations per temp,
% Tmin=stopping temp, MaxNoImprove=max iterations without improvement
defSA = struct('T0', 1.0, 'alpha', 0.90, 'L', 50, 'Tmin', 1e-3, 'MaxNoImprove', 300);
SAParams = apply_default(SAParams, defSA);

% Initialize attack parameters (budget, costs, invulnerable components) if missing
if nargin < 5 || isempty(AttackParams)
    AttackParams = struct();
end
% Enforce budget requirement (critical for attack feasibility)
if ~isfield(AttackParams, 'Budget')
    error('AttackParams must contain the ''Budget'' field (total allowable attack cost).');
end

% Extract IDs of all components from power and water systems
PnodeID = [PowerSystem.Node.ID];      Np = numel(PnodeID);  % Number of power nodes
PedgeID = [PowerSystem.Edge.ID];      Ep = numel(PedgeID);  % Number of power edges
WnodeID = [WaterSystem.Node.ID];      Nw = numel(WnodeID);  % Number of water nodes
WedgeID = [WaterSystem.Edge.ID];      Ew = numel(WedgeID);  % Number of water edges

% Get attack costs for each component (default to 1 if not specified)
% Validate cost vector length matches component count
cPnode = get_or_default(AttackParams, 'PowerNodeAttackCost', ones(1, Np), Np);
cPedge = get_or_default(AttackParams, 'PowerEdgeAttackCost', ones(1, Ep), Ep);
cWnode = get_or_default(AttackParams, 'WaterNodeAttackCost', ones(1, Nw), Nw);
cWedge = get_or_default(AttackParams, 'WaterEdgeAttackCost', ones(1, Ew), Ew);

% Define invulnerable components (cannot be attacked) - deduplicate IDs
invPN = unique(get_or_default(AttackParams, 'InvulPowerNode', [], 0));  % Invulnerable power nodes
invPE = unique(get_or_default(AttackParams, 'InvulPowerEdge', [], 0));  % Invulnerable power edges
invWN = unique(get_or_default(AttackParams, 'InvulWaterNode', [], 0));  % Invulnerable water nodes
invWE = unique(get_or_default(AttackParams, 'InvulWaterEdge', [], 0));  % Invulnerable water edges

% Initialize invalid attack strategies (optional rules to exclude specific combinations)
InvalidStrategy = [];
if isfield(AttackParams, 'InvalidStrategy') && ~isempty(AttackParams.InvalidStrategy)
    InvalidStrategy = AttackParams.InvalidStrategy;
end

% Extract total attack budget (finalize after parameter initialization)
Budget = AttackParams.Budget;

%% ------------------------ 1. Unified Coding & Feasible Region Definition ------------------------
% Map 4 component types to non-overlapping global indices for unified processing (1-based indexing)
idx.Pnode = 1:Np;                          % Global indices for power nodes
idx.Pedge = Np + (1:Ep);                   % Global indices for power edges
idx.Wnode = Np + Ep + (1:Nw);              % Global indices for water nodes
idx.Wedge = Np + Ep + Nw + (1:Ew);         % Global indices for water edges
Ntot = Np + Ep + Nw + Ew;                  % Total number of components across both systems

% Build global cost array (cost to attack each component)
cost = zeros(1, Ntot);
cost(idx.Pnode) = cPnode;
cost(idx.Pedge) = cPedge;
cost(idx.Wnode) = cWnode;
cost(idx.Wedge) = cWedge;

% Create mask for attackable components (true = can be attacked; false = invulnerable)
canAttack = true(1, Ntot);
% Mark invulnerable components as unattackable
canAttack(idx.Pnode(ismember(PnodeID, invPN))) = false;
canAttack(idx.Pedge(ismember(PedgeID, invPE))) = false;
canAttack(idx.Wnode(ismember(WnodeID, invWN))) = false;
canAttack(idx.Wedge(ismember(WedgeID, invWE))) = false;

% Handle non-positive attack costs (invalid, mark as unattackable)
if any(cost <= 0)
    warnIdx = find(cost <= 0);
    warning('Non-positive attack costs detected. Marked %d components as unattackable.', numel(warnIdx));
    canAttack(warnIdx) = false;
    cost(warnIdx) = inf;  % Set cost to infinity to prevent accidental selection
end

% Get indices of feasible attack candidates (attackable components)
candIdx = find(canAttack);
% Edge case: No attackable components (return empty strategy)
if isempty(candIdx)
    warning('No attackable components available. Returning empty attack strategy.');
    AttackStrategy = empty_strategy();
    [PowerSysFunLoss, WaterSysFunLoss] = evaluate_strategy([], idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
        PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams);
    return;
end

%% ------------------------ 2. Initial Solution Generation (Random Feasible) ------------------------
x = false(1, Ntot);  % Binary vector representing attack selection (true = attacked)
% Shuffle candidate components to ensure random initial selection
candShuffled = candIdx(randperm(numel(candIdx)));
remainB = Budget;    % Remaining budget for building the initial solution

% Construct initial solution by selecting components within budget (check invalid rules)
for k = 1:numel(candShuffled)
    j = candShuffled(k);
    % Select component if its cost is within remaining budget
    if cost(j) <= remainB
        x(j) = true;
        % Revert selection if it violates invalid strategy rules
        if ~is_valid_with_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidStrategy)
            x(j) = false;
        else
            remainB = remainB - cost(j);  % Update remaining budget
        end
    end
end
% Final budget repair (ensure initial solution does not exceed budget)
x = repair_budget(x, cost, Budget, idx);

% Evaluate initial solution: get functionality losses and objective function J
[PowerSysFunLoss, WaterSysFunLoss, Jx] = ...
    evaluate_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
        PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams);

% Initialize tracker for the best solution found
best.x   = x;               % Best attack selection vector
best.J   = Jx;              % Best objective value (smallest = worst attack)
best.FPL = PowerSysFunLoss; % Best power system functionality loss
best.FWL = WaterSysFunLoss; % Best water system functionality loss

%% ------------------------ 3. Simulated Annealing Main Loop ------------------------
% Extract SA parameters from the structured input
T        = SAParams.T0;          % Initial temperature
L        = SAParams.L;           % Number of iterations per temperature level
alp      = SAParams.alpha;       % Cooling rate (T = T * alp each cycle)
Tmin     = SAParams.Tmin;        % Minimum temperature to stop SA
maxNoImp = SAParams.MaxNoImprove;% Max iterations without improvement (stopping condition)
noImpCount = 0;                  % Counter for iterations without improvement

% Initialize evaluation cache: stores J and functionality losses for existing attack vectors
% (avoids redundant MILP computations for repeated selections)
eval_cache = containers.Map('KeyType', 'char', 'ValueType', 'any');

% Cache the initial solution's evaluation results
key = key_of(x);
eval_cache(key) = {Jx, PowerSysFunLoss, WaterSysFunLoss};

% SA main loop: run until temperature is too low or no improvement for maxNoImp cycles
while T > Tmin && noImpCount < maxNoImp
    improved_in_T = false;  % Flag to track if current temperature level improves the best solution

    % Perform L iterations at the current temperature
    for it = 1:L
        % Generate a neighborhood solution (add/drop/swap a component)
        x_new = neighbor(x, canAttack, cost, Budget, idx);

        % Check and fix invalid strategies (if rules are defined)
        if ~is_valid_with_rules(x_new, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidStrategy)
            % Simple repair: randomly remove one attacked component to resolve invalidity
            x_new = fix_invalid_rules(x_new, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidStrategy);
        end
        % Ensure the new solution is budget-feasible
        x_new = repair_budget(x_new, cost, Budget, idx);

        % Look up cached evaluation or compute new results
        key = key_of(x_new);
        if isKey(eval_cache, key)
            % Retrieve cached data to avoid redundant computation
            val = eval_cache(key);
            Jnew = val{1};       % New solution's objective value
            Pnew = val{2};       % New power system functionality loss
            Wnew = val{3};       % New water system functionality loss
        else
            % Evaluate the new solution if not in cache
            [Pnew, Wnew, Jnew] = evaluate_strategy(x_new, idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
                PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams);
            % Store results in cache for future use
            eval_cache(key) = {Jnew, Pnew, Wnew};
        end

        % Metropolis criterion: decide whether to accept the new solution
        dJ = Jnew - Jx;  % Difference in objective (dJ < 0 = better solution)
        if dJ < 0 || rand < exp(-dJ / max(T, eps))  % Accept better or worse solutions (with probability)
            % Update current solution to the new accepted solution
            x = x_new;
            Jx = Jnew;
            PowerSysFunLoss = Pnew;
            WaterSysFunLoss = Wnew;

            % Update the best solution if the current solution is significantly better
            if Jx < best.J - 1e-12
                best.x = x;
                best.J = Jx;
                best.FPL = PowerSysFunLoss;
                best.FWL = WaterSysFunLoss;
                improved_in_T = true;  % Mark this temperature level as improved
            end
        end
    end

    % Cool down the temperature for the next cycle
    T = T * alp;
    % Update no-improvement counter: reset if improved, increment otherwise
    if improved_in_T
        noImpCount = 0;
    else
        noImpCount = noImpCount + 1;
    end
end

%% ------------------------ 4. Output Optimal Solution ------------------------
% Convert the best binary attack vector to a structured attack strategy (component IDs)
AttackStrategy = vec_to_strategy(best.x, idx, PnodeID, PedgeID, WnodeID, WedgeID);
% Extract functionality losses from the best solution
PowerSysFunLoss = best.FPL;
WaterSysFunLoss = best.FWL;

end

%% ====================== Helper Function Section ======================
function S = empty_strategy()
% empty_strategy: Create an empty attack strategy structure (no components attacked)
% Output:
%   - S: Empty strategy structure with fields for power and water system components
S.Power.Node = [];
S.Power.Edge = [];
S.Water.Node = [];
S.Water.Edge = [];
end

function SA = apply_default(SA, DEF)
% apply_default: Fill missing fields in the SA parameter structure with default values
% Inputs:
%   - SA: Input SA structure (may have missing fields)
%   - DEF: Structure containing default values for all required SA fields
% Output:
%   - SA: Updated SA structure with missing fields populated by defaults
fns = fieldnames(DEF);
for i = 1:numel(fns)
    f = fns{i};
    % Set to default if field is missing or empty
    if ~isfield(SA, f) || isempty(SA.(f))
        SA.(f) = DEF.(f);
    end
end
end

function v = get_or_default(st, fname, defv, expectLen)
% get_or_default: Retrieve a value from a structure field, or return a default if missing/empty
% Inputs:
%   - st: Input structure to query
%   - fname: Name of the field to retrieve
%   - defv: Default value to use if the field is missing or empty
%   - expectLen: Expected length of the value (0 = no length check)
% Output:
%   - v: Retrieved or default value (throws error if length mismatch)
if isfield(st, fname) && ~isempty(st.(fname))
    v = st.(fname);
else
    v = defv;
end
% Validate length if required (ensures consistency with component counts)
if expectLen > 0 && numel(v) ~= expectLen
    error('Field ''%s'' length mismatch: Expected %d, got %d.', fname, expectLen, numel(v));
end
end

function key = key_of(x)
% key_of: Generate a unique string key for a binary attack vector (for cache lookup)
% Input:
%   - x: Binary vector (true = component is attacked, false = not attacked)
% Output:
%   - key: Comma-separated string of attacked component indices (empty = '[]')
idx = find(x);
if isempty(idx)
    key = '[]';
    return;
end
key = sprintf('%d,', idx);
end

function x = repair_budget(x, cost, B, idx)
% repair_budget: Ensure an attack vector stays within budget by removing high-cost components
% Inputs:
%   - x: Binary attack vector (may exceed budget)
%   - cost: Array of attack costs for all components
%   - B: Maximum allowable attack budget
%   - idx: Structure of global indices (unused here but retained for function signature consistency)
% Output:
%   - x: Budget-feasible binary attack vector
% Exit early if already within budget
tot_cost = sum(cost(x));
if tot_cost <= B
    return;
end
% Get indices of currently attacked components
sel = find(x);
% Sort attacked components by cost (descending: remove most expensive first for efficiency)
[~, ord] = sort(cost(sel), 'descend');
% Remove components until budget is satisfied
for k = 1:numel(ord)
    x(sel(ord(k))) = false;
    if sum(cost(x)) <= B
        break;
    end
end
end

function ok = is_valid_with_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidRule)
% is_valid_with_rules: Check if an attack vector violates invalid strategy rules
% Inputs:
%   - x: Binary attack vector to validate
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
%   - InvalidRule: Invalid strategy rules (supports 3 types: function handle, struct array, cell array)
% Output:
%   - ok: true = valid (no rule violation), false = invalid
ok = true;
% Exit early if no invalid rules are defined
if isempty(InvalidRule)
    return;
end

% Convert binary vector to structured attack strategy for rule checking
S = vec_to_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID);

% Handle rule type: Function handle (returns true if invalid)
if isa(InvalidRule, 'function_handle')
    ok = ~InvalidRule(S);  % Invert result (function returns true = invalid)
    return;
end

% Handle rule types: Struct array or cell array (try-catch for robustness)
try
    if isstruct(InvalidRule)
        % Rule type 1: Struct array (each struct defines mutually exclusive components of the same type)
        % Structure fields: .Type (component type, e.g., 'Pnode'), .IDs (mutually exclusive IDs)
        for i = 1:numel(InvalidRule)
            comp_type = InvalidRule(i).Type;
            excl_ids = InvalidRule(i).IDs(:)';
            % Get IDs of attacked components of the specified type
            attacked_ids = pick_ids(S, comp_type);
            % Violation if 2+ mutually exclusive components are attacked
            if numel(intersect(attacked_ids, excl_ids)) >= 2
                ok = false;
                return;
            end
        end
    elseif iscell(InvalidRule)
        % Rule type 2: Cell array (each cell defines a set of components that cannot all be attacked)
        % Cell format: Each element is a sub-cell like {{'Pnode', ID1}, {'Wedge', ID2}, ...}
        for i = 1:numel(InvalidRule)
            forbidden_set = InvalidRule{i};
            hit_count = 0;  % Count of components in forbidden_set that are attacked
            for j = 1:numel(forbidden_set)
                comp_type = forbidden_set{j}{1};
                comp_id = forbidden_set{j}{2};
                attacked_ids = pick_ids(S, comp_type);
                hit_count = hit_count + ismember(comp_id, attacked_ids);
            end
            % Violation if all components in the forbidden set are attacked
            if hit_count == numel(forbidden_set)
                ok = false;
                return;
            end
        end
    end
catch
    % Ignore invalid rules if parsing fails (issue warning)
    warning('Failed to parse InvalidStrategy rules. Ignoring invalid combination checks.');
end
end

function Sids = pick_ids(S, comp_type)
% pick_ids: Extract IDs of attacked components for a specified type from the strategy structure
% Inputs:
%   - S: Structured attack strategy
%   - comp_type: Component type ('Pnode', 'Pedge', 'Wnode', 'Wedge')
% Output:
%   - Sids: IDs of attacked components (empty if none)
switch comp_type
    case 'Pnode'
        Sids = S.Power.Node;
    case 'Pedge'
        Sids = S.Power.Edge;
    case 'Wnode'
        Sids = S.Water.Node;
    case 'Wedge'
        Sids = S.Water.Edge;
    otherwise
        Sids = [];  % Return empty for unrecognized component types
end
end

function x = fix_invalid_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidRule)
% fix_invalid_rules: Repair an invalid attack vector by randomly removing attacked components
% Inputs:
%   - x: Invalid binary attack vector
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
%   - InvalidRule: Invalid strategy rules
% Output:
%   - x: Valid binary attack vector (or original if repair fails after 20 attempts)
% Exit early if no invalid rules are defined
if isempty(InvalidRule)
    return;
end

iter = 0;
max_iter = 20;  % Limit iterations to avoid infinite loops
% Keep removing random attacked components until valid or max iterations
while ~is_valid_with_rules(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, InvalidRule) && iter < max_iter
    % Get indices of attacked components (cannot repair if none are attacked)
    sel = find(x);
    if isempty(sel)
        break;
    end
    % Randomly remove one attacked component
    j = sel(randi(numel(sel)));
    x(j) = false;
    iter = iter + 1;
end
end

function x_new = neighbor(x, canAttack, cost, B, idx)
% neighbor: Generate a neighborhood solution from the current attack vector
% Inputs:
%   - x: Current binary attack vector
%   - canAttack: Mask of attackable components (true = can be attacked)
%   - cost: Array of attack costs
%   - B: Maximum attack budget
%   - idx: Structure of global indices (unused here but retained for function signature consistency)
% Output:
%   - x_new: Neighborhood solution (feasible after budget repair)
x_new = x;
% Randomly select neighborhood operation (1=add, 2=drop, 3=swap)
op_type = randi(3);

% Get indices of attacked and available (attackable but not attacked) components
attacked_idx = find(x);
available_idx = find(~x & canAttack);

switch op_type
    case 1  % Add operation: Attack one additional available component
        if ~isempty(available_idx)
            x_new(available_idx(randi(numel(available_idx)))) = true;
        end
    case 2  % Drop operation: Stop attacking one already attacked component
        if ~isempty(attacked_idx)
            x_new(attacked_idx(randi(numel(attacked_idx)))) = false;
        end
    case 3  % Swap operation: Replace one attacked component with one available component
        if ~isempty(attacked_idx) && ~isempty(available_idx)
            x_new(attacked_idx(randi(numel(attacked_idx)))) = false;
            x_new(available_idx(randi(numel(available_idx)))) = true;
        end
end

% Repair budget to ensure the new solution is feasible
x_new = repair_budget(x_new, cost, B, idx);
end

function [PfunLoss, WfunLoss, J] = evaluate_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID, ...
    PowerSystem, WaterSystem, PowerWaterInterdependency, TerminalZone, OperatorParams)
% evaluate_strategy: Compute functionality losses and objective function J for an attack vector
% Inputs:
%   - x: Binary attack vector (empty = no attack)
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
%   - PowerSystem/WaterSystem: System data structures
%   - PowerWaterInterdependency: System interdependency structure
%   - OperatorParams: Operational parameters for functionality evaluation
% Outputs:
%   - PfunLoss: 1x3 power system metrics [loss, post-attack func, initial func]
%   - WfunLoss: 1x3 water system metrics [loss, post-attack func, initial func]
%   - J: Objective function (sum of normalized remaining functionalities)

% Handle empty attack vector (no components attacked)
if isempty(x)
    x = false(1, idx.Wedge(end));  % Initialize to all false
end

% Get global indices of attacked components
sel = find(x);

% Map global attacked indices to original component IDs for each system
% Power system: Map global indices to power node/edge IDs
selPN = intersect(sel, idx.Pnode);
idsPN = PnodeID(ismember(1:numel(PnodeID), selPN - idx.Pnode(1) + 1));
selPE = intersect(sel, idx.Pedge);
idsPE = PedgeID(ismember(1:numel(PedgeID), selPE - idx.Pedge(1) + 1));

% Water system: Map global indices to water node/edge IDs
selWN = intersect(sel, idx.Wnode);
idsWN = WnodeID(ismember(1:numel(WnodeID), selWN - idx.Wnode(1) + 1));
selWE = intersect(sel, idx.Wedge);
idsWE = WedgeID(ismember(1:numel(WedgeID), selWE - idx.Wedge(1) + 1));

% Format damage scenarios for the evaluation function: [DamageType, ComponentID]
% DamageType: 1 = node, 2 = edge
PowerComDamgScenario = [repmat(1, numel(idsPN), 1), idsPN(:); repmat(2, numel(idsPE), 1), idsPE(:)];
WaterComDamgScenario = [repmat(1, numel(idsWN), 1), idsWN(:); repmat(2, numel(idsWE), 1), idsWE(:)];

% Call external function to compute post-attack functionality losses
[PfunLoss, WfunLoss] = GlobalOptPowerDCPFWaterMF( ...
    PowerSystem, WaterSystem, PowerWaterInterdependency, ...
    PowerComDamgScenario, WaterComDamgScenario, TerminalZone, OperatorParams);

% Compute normalized remaining functionality (avoid division by zero with eps)
norm_power = safe_div(PfunLoss(2), max(PfunLoss(3), eps));  % Post/Initial power functionality
norm_water = safe_div(WfunLoss(2), max(WfunLoss(3), eps));  % Post/Initial water functionality

% Objective function: sum of normalized remaining functionalities (smaller = worse attack)
J = norm_power + norm_water;
end

function val = safe_div(a, b)
% safe_div: Perform division with protection against division by zero
% Inputs:
%   - a: Numerator
%   - b: Denominator
% Output:
%   - val: a/b if b ~= 0, otherwise 0
if b == 0
    val = 0;
else
    val = a / b;
end
end

function S = vec_to_strategy(x, idx, PnodeID, PedgeID, WnodeID, WedgeID)
% vec_to_strategy: Convert a binary attack vector to a structured attack strategy
% Inputs:
%   - x: Binary attack vector (true = component is attacked)
%   - idx: Structure of global indices for component types
%   - PnodeID/PedgeID: Power system node/edge IDs
%   - WnodeID/WedgeID: Water system node/edge IDs
% Output:
%   - S: Structured attack strategy with attacked component IDs
% Initialize empty strategy
S = empty_strategy();

% Map power system components from binary vector to IDs
if any(x(idx.Pnode))
    map = logical(x(idx.Pnode));
    S.Power.Node = PnodeID(map);
end
if any(x(idx.Pedge))
    map = logical(x(idx.Pedge));
    S.Power.Edge = PedgeID(map);
end

% Map water system components from binary vector to IDs
if any(x(idx.Wnode))
    map = logical(x(idx.Wnode));
    S.Water.Node = WnodeID(map);
end
if any(x(idx.Wedge))
    map = logical(x(idx.Wedge));
    S.Water.Edge = WedgeID(map);
end
end